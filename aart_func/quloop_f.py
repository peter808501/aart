from aart_func import *
from params import *

# this function takes in alpha, beta, rs, phi, sign arrays as generated by lensingbands.py and raytracing.py (Remember to apply the mask0!)
# it first selects for the elements close to the specified constant emission radius, and then sorts the array
def select_and_sort(alpha, beta, rs, phi, sign, r_emission, tolerance):
    
    """params: 
    1. alpha: alpha coordinates on observer screen
    2. beta: beta coordinates on observer screen
    3. rs: emission radius in source plane
    4. phi: phi angle in source plane
    5. sign: sign of p_r"""
    
    # define the upper and lower bounds 
    upper = r_emission + tolerance
    lower = r_emission - tolerance
    
    # create the mask that select for the elements within these bounds
    mask = (rs > lower) & (rs < upper)
    
    # apply the mask
    alpha_r = alpha[mask]
    beta_r = beta[mask]
    rs_r = rs[mask]
    phi_r = phi[mask]
    sign_r = sign[mask]
    
    # next, we sort the phi array from smallest to largest, while keeping the same one-to-one correspondence between the arrays. 
    sort_indices = np.argsort(phi_r)
    
    alpha_r = alpha_r[sort_indices]
    beta_r = beta_r[sort_indices]
    phi_r = phi_r[sort_indices]
    rs_r = rs_r[sort_indices]
    sign_r = sign_r[sort_indices]

    # we return the sorted arrays
    return alpha_r, beta_r, rs_r, phi_r, sign_r


# this function takes in the sorted phi array and returns the indices of the elements that are closest to the values of 0, -pi/2, -pi, -3pi/2
# these indices will later be used to label the QU loops. You may change the values accordingly if you want to label different parts of the QU loop
def phi_indices(phi_r): 
    """params:
    1. phi_r: the sorted phi array"""
    
    # next, we want to label where phi = 0, -pi/2, -pi, and -3pi/2. First, we have to find the indices corresponding to these values
    # we construct an array whose elements are the distance between each element in phi_r and the desired value (0, -pi/2, ...)
    # then we select for the index of the smallest element
    abs0 = np.abs(phi_r)
    phi_0_index = np.argmin(abs0)

    abs90 = np.abs(phi_r + np.pi/2)
    phi_90_index = np.argmin(abs90)

    abs180 = np.abs(phi_r + np.pi)
    phi_180_index = np.argmin(abs180)

    abs270 = np.abs(phi_r + 3*np.pi/2)
    phi_270_index = np.argmin(abs270)
    
    return phi_0_index, phi_90_index, phi_180_index, phi_270_index

# this function calculates the physical quantities necessary to find the Q and U arrays. 
def calculate_quantities(alpha_r, beta_r, rs_r, phi_r, sign_r):
    
    """params:
    1. alpha_r: sorted alpha array
    2. beta_r: sorted beta array
    3. rs_r: sorted rs array
    4. phi_r: sorted phi array
    5. sign_r: sorted sign array
    """

    # the conserved quantities lam(angular_momentum) and eta(carter constant) using a function from raytracing.py
    # Zack's paper, equation 14, but calculated using AART code.
    lam_r, eta_r = rt.conserved_quantities(alpha_r, beta_r, i_case * np.pi/180, spin_case)

    # then, we calculate all the quantities defined in equation 2 of Zack's paper
    delta_r = rs_r**2 - 2*rs_r + spin_case**2
    xi_r = (rs_r**2 + spin_case**2)**2 - delta_r * (spin_case**2) # here, we are taking theta = pi/2. This is a correction from previously where I mistook theta for i_case. 
    omega_zamo_r = (2 * spin_case * rs_r) / xi_r
    chi = -np.pi/2

    # then, we find the radial potential
    # Zack's paper equation 10, here using AART function from raytracing.py
    v_rad_r = rt.radial_potential(rs_r, spin_case, lam_r, eta_r)
    
    return lam_r, eta_r, delta_r, xi_r, omega_zamo_r, chi, v_rad_r

# this function returns the lowered momenta in Boyer-Lindquist
# Zack's paper page 5 equation 23
def lowered_momenta(sign, lam, eta, delta, v_rad):
    """params: 
    1. sign: sign of p_r, as given by aart
    2. lam: angular momentum
    3. eta: carter constant
    4. delta: same delta as throughout the code
    5. v_rad: radial potential"""
    p_lower_t = -1
    p_lower_r = sign * np.sqrt(v_rad) / delta
    """What is the sign of this?"""
    p_lower_theta = - np.sqrt(eta)
    p_lower_phi = lam
    return np.array([p_lower_t, p_lower_r, p_lower_theta, p_lower_phi])

# this function calculates the raised momentum in Boyer_Lindquist
# Zack's paper page 5 equation 24
def raised_momentum(r, sign, lam, eta, delta, v_rad):
    """params: 
    1. r: emission radius
    2. sign: sign of p_r, as given by aart
    3. lam: angular momentum
    4. eta: carter constant
    5. delta: same delta as throughout the code
    6. v_rad: radial potential"""
    p_upper_t = 1 / (r**2) * (-spin_case * (spin_case - lam) + (r**2 + spin_case**2) * (r**2 + spin_case**2 - spin_case * lam) / delta)
    p_upper_r = sign * np.sqrt(v_rad) / r**2
    p_upper_theta = -np.sqrt(eta) / r**2
    p_upper_phi = 1/(r**2) * (-(spin_case -lam) + (spin_case * (r**2 + spin_case**2 - spin_case * lam)) / delta)
    return p_upper_t, p_upper_r, p_upper_theta, p_upper_phi

# this function calculates the real and imaginary components of the Penrose-Walker Constant
def penrose_walker(r, f_t, f_r, f_theta, f_phi, p_upper_t, p_upper_r, p_upper_theta, p_upper_phi):
    """params:
    1. r: the emission radius
    2. f_t, f_r, f_theta, f_phi: the polarization in Boyer-Lindquist coordinates
    3. p_upper_t, p_upper_r, p_upper_theta, p_upper_phi: raised momentum in Boyer-Lindquist"""
    AA = (p_upper_t * f_r - p_upper_r * f_t) + spin_case * (p_upper_r * f_phi - p_upper_phi * f_r)
    BB = (r**2 + spin_case**2) * (p_upper_phi * f_theta - p_upper_theta * f_phi) - spin_case * (p_upper_t * f_theta - p_upper_theta * f_t)
    k1 = r * AA
    k2 = -r * BB
    return k1, k2

# this function calculates the observer falpha and fbeta, the observed polarization
# Zack's paper page 6 equation 31 and 33 and 34 and 35
def evpa_components(alpha, beta, k1, k2, redshift, lp=1):
    """params: 
    1. alpha: alpha observer screen coordinates
    2. beta: beta observer screen coordinates
    3. k1: real component of Penrose-Walker constant
    4. k2: imaginary component of Penrose-Walker constant
    5. redshift: redshift according to Zack page 6 equation 33
    6. lp: path length difference according Zack page 6 equation 34 (always taken to be 1 for these QU loops)
    """
    # calculate falpha and fbeta
    # Zack's paper page 6 equation 31
    nu = -(alpha + spin_case * np.sin(i_case * np.pi/180))
    falpha = (beta * k2 - nu * k1) / (nu**2 + beta**2)
    fbeta = (beta * k1 + nu * k2) / (nu**2 + beta**2)
    
    falpha *= redshift**2 * np.sqrt(np.abs(lp))
    fbeta *= redshift**2 * np.sqrt(np.abs(lp))
    
    return falpha, fbeta

# this function calculates Q and U 
def find_qu(falpha, fbeta):
    """params: 
    1. falpha, fbeta: the obsered polarization"""
    
    q_element = fbeta**2 - falpha**2
    u_element = -2 * falpha * fbeta
    
    return q_element, u_element
    

# The exact formula for the matrix can be found in Appendix A equation A1 in Zack's paper (Zachary Gelles, Polarized Image of Equatorial Emission in the Kerr Geometry, 2021)
# quantities like delta, xi, and omega_zamo are found in equation 2 of Zack's paper.
def zamo_transform_matrix(rs, delta, xi, omega_zamo):
    """params:
    1. rs: emission radius
    2. delta, xi, omega_zamo: see calculate_quantities()"""
    entry1_1 = (1/rs) * np.sqrt(xi/delta)
    entry1_4 = (omega_zamo / rs) * np.sqrt(xi/delta)
    entry2_2 = np.sqrt(delta) / rs
    entry3_4 = rs / (np.sqrt(xi))
    entry4_3 = - (1/rs)
    return np.array([[entry1_1, 0, 0, entry1_4], [0, entry2_2, 0, 0], [0, 0, 0, entry3_4], [0, 0, entry4_3, 0]])

# Zack's paper Appendix A equation A3
def boost_transform_matrix(rs):
    """params:
    1. rs: emission radius"""
    beta_f = -((spin_case**2 - 2 * np.abs(spin_case) * np.sqrt(rs) + rs**2) / (np.sqrt(spin_case**2 + rs * (rs -2)) * (np.abs(spin_case) + rs**1.5)))
    """Why did Zack put the negative boost here?"""
    # beta = 1 / np.sqrt(rs - 2)
    kai = - np.pi/2
    gamma = 1/(np.sqrt(1-beta_f**2))
    bentry1_1 = gamma
    bentry1_2 = -beta_f*gamma*np.cos(kai)
    bentry1_3 = -beta_f*gamma*np.sin(kai)
    bentry2_1 = bentry1_2
    bentry2_2 = (gamma-1) * (np.cos(kai))**2 + 1
    bentry2_3 = (gamma-1) * np.cos(kai) * np.sin(kai)
    bentry3_1 = bentry1_3 
    bentry3_2 = bentry2_3
    bentry3_3 = (gamma-1) * (np.sin(kai))**2 + 1
    return np.array ([[bentry1_1, bentry1_2, bentry1_3, 0], [bentry2_1, bentry2_2, bentry2_3, 0], [bentry3_1, bentry3_2, bentry3_3, 0], [0, 0, 0, 1] ])


# next, we build the overall coordinate transform from the local frame to the observer frame
# Zack's code kerrtoymodel.py in the function named getevec()
def coordtransform(rs, delta, xi, omega_zamo): 
    """params:
    1. rs: emission radius
    2. delta, xi, omega_zamo: see calculate_quantities()"""
    minkmetric = np.diag([-1, 1, 1, 1])
    coordtransform = np.matmul(np.matmul(minkmetric, boost_transform_matrix(rs)), zamo_transform_matrix(rs, delta, xi, omega_zamo))
    return coordtransform

# and we also find its inverse
def coordtransforminverse(rs, delta, xi, omega_zamo):
    """params:
    1. rs: emission radius
    2. delta, xi, omega_zamo: see calculate_quantities()"""
    return np.transpose(np.matmul(boost_transform_matrix(rs), zamo_transform_matrix(rs, delta, xi, omega_zamo)))



"""remember to somehow find redshift and lp, maybe just inside the master function"""


# this is the master function that calculates the Q and U arrays, which the user can use to plot the Q and U loops. 
def quloop(alpha, beta, rs, phi, sign, bvec, r_emission, tolerance):
    """params:
    1. alpha: alpha observer screen coordinates
    2. alpha: alpha coordinates on observer screen
    2. beta: beta coordinates on observer screen
    3. rs: emission radius in source plane
    4. phi: phi angle in source plaine
    5. sign: sign of p_r"""
    
    # first, we select and sort the arrays. 
    alpha_r, beta_r, rs_r, phi_r, sign_r = select_and_sort(alpha, beta, rs, phi, sign, r_emission, tolerance)
    
    # second, find the indices that correspond to certain phi values.
    phi_0_index, phi_90_index, phi_180_index, phi_270_index = phi_indices(phi_r)
    
    # third, calculate the necessary physical quantities
    lam_r, eta_r, delta_r, xi_r, omega_zamo_r, chi, v_rad_r = calculate_quantities(alpha_r, beta_r, rs_r, phi_r, sign_r)
    
    # creat the empty Q and U arrays 
    Q = []
    U = []
    
    for i, r in enumerate(rs_r): 
        
        # define the individual quantities
        alpha = alpha_r[i]
        beta = beta_r[i]
        sign = sign_r[i]
        lam = lam_r[i]
        eta = eta_r[i]
        delta = delta_r[i]
        xi = xi_r[i]
        omega_zamo = omega_zamo_r[i]
        chi = -np.pi/2
        v_rad = v_rad_r[i]
        
        # defined the lowered momentum in Boyer-Lindquist
        p_lower_matrix = lowered_momenta(sign, lam, eta, delta, v_rad)
        
        # transform p_lower_matrix to local frame
        p_local_matrix = np.matmul(coordtransform(r, delta, xi, omega_zamo), p_lower_matrix)
        
        # define redshift and path length difference
        redshift = 1 / p_local_matrix[0]
        """could change to something not a constant for lp, like something according to Zack paper equation 34 page 6"""
        lp = 1
        
        # take the cross product of p_local_matrix and b_array to find the local polarization
        # and then insert 0 as the t coordinate, and normalize it
        # Zack's paper page 5 equation 25
        local_polarization = np.cross(p_local_matrix[1:], bvec)
        local_polarization = np.insert(local_polarization, 0, 0) / np.linalg.norm(p_local_matrix[1:])
        
        # now we transform the local polarization back into Boyer-Lindquist
        upper_polarization = np.matmul(coordtransforminverse(r, delta, xi, omega_zamo), local_polarization)
        f_t = upper_polarization[0]
        f_r = upper_polarization[1]
        f_theta = upper_polarization[2]
        f_phi = upper_polarization[3]
        
        # now we calculate the raised momentum in Boyer_Lindquist
        # Zack's paper page 5 equation 24
        p_upper_t, p_upper_r, p_upper_theta, p_upper_phi = raised_momentum(r, sign, lam, eta, delta, v_rad)
        
        # calculate Penrose-Walker Constant
        k1, k2 = penrose_walker(r, f_t, f_r, f_theta, f_phi, p_upper_t, p_upper_r, p_upper_theta, p_upper_phi)
        
        # calculate falpha and fbeta, the observed polarization
        falpha, fbeta = evpa_components(alpha, beta, k1, k2, redshift, lp=1)
        
        # calculate the q and u (individual, for the current screen coordinate only)
        q_element, u_element = find_qu(falpha, fbeta)
        
        # append these individual elements to the Q, U arrays
        Q.append(q_element)
        U.append(u_element)
        
        # now we wish to label specific values of phi.
        if (i == phi_0_index): 
            plt.scatter(q_element, u_element, s = 50, color = "black")
            plt.text(q_element, u_element -0.08, r"$\phi$ = $0^\circ$", fontsize = 8)
        
        if (i == phi_90_index): 
            plt.scatter(q_element, u_element, s = 50, color = "black")
            plt.text(q_element, u_element - 0.08, r"$\phi$ = $-90^\circ$", fontsize = 8)

        if (i == phi_180_index): 
            plt.scatter(q_element, u_element, s = 50, color = "black")
            plt.text(q_element, u_element - 0.09, r"$\phi$ = $-180^\circ$", fontsize = 8)

        if (i == phi_270_index): 
            plt.scatter(q_element, u_element, s = 50, color = "black")
            plt.text(q_element, u_element + 0.08, r"$\phi$ = $-270^\circ$", fontsize = 8)
            
    return Q, U
        
        
        
        
        
        
        
        
        
    
    
    
    
    

